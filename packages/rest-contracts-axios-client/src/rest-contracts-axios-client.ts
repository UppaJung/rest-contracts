import Axios, { AxiosPromise, AxiosRequestConfig } from "axios";
import * as RestContracts from "rest-contracts";

export type RequestOptions = AxiosRequestConfig;

async function wrapAxiosPromise<T>(axiosPromise: AxiosPromise<T>) {
  try {
    const { data } = await axiosPromise;
    return data;
  } catch (error) {
    if (
      error != null && error.response && error.response.data &&
      error.response.data.error &&
      typeof (error.response.data.error) === "string"
    ) {
      throw JSON.parse(error.response.data.error);
    }
    throw error;
  }
}

function assemblePath(
  pathComponentArrayReadOnly: string[],
  parameterToIndexMap: Map<string, number>,
  pathParameters: RestContracts.PathParametersType = {}
): {
  pathWithParameters: string,
  remainingParameters: {[attribute: string]: any}
}  {
  const remainingParameters = {...pathParameters};
  const parameterIndexesSet = new Set(parameterToIndexMap.values());

  const pathWithParameters = "/" + pathComponentArrayReadOnly
    .map((pathComponent, index) => {
      if (!parameterIndexesSet.has(index)) {
        return pathComponent;
      }

      const pathParameterKey = pathComponent.replace(/[:?]/g, "");

      const value = pathParameters[pathParameterKey];
      delete remainingParameters[pathParameterKey];

      if (value) {
        return encodeURIComponent(value);
      }

      return null;
    })
    .filter(Boolean)
    .join("/");

  return {pathWithParameters, remainingParameters};
}

/**
 * Create a factory that will generated a promise-based client functions
 * to call the corresponding API function on the server.
 *
 * @param baseUrl The URL of the API server
 * @param defaultOptions Use to set default options for all API calls
 *   generated by this factory, which can be overriden during individual
 *   calls.  Options are timeoutInMs (default 0 indicating no timeout),
 *   headers (none), noCache (false), and withCredentials (true).
 */
export const getClientCreationFunction = (
  defaultBaseUrl: string = "",
  factoryDefaultOptions: RequestOptions = {}
) => <API extends RestContracts.AtPath & RestContracts.UsesMethod>(
    api: API,
    baseUrl: string = defaultBaseUrl,
    apiDefaultOptions: RequestOptions = {},
  ): RestContracts.ClientFunction<API, RequestOptions>  => {
    const defaultOptions: RequestOptions = {...factoryDefaultOptions, ...apiDefaultOptions};
    // Remove any trailing slashes from the base URL since the path will start with a slash
    baseUrl = baseUrl.replace(/\/+$/, "")
    const pathWithStartingSlash = (
      (baseUrl.length > 0 && baseUrl.charAt(baseUrl.length - 1) !== "/" && api.path.length > 0 && api.path.charAt(0) !== "/") ?
        "/" :
        ""
      ) + api.path;
    const pathWithoutStartingSlash = pathWithStartingSlash.substr(1);
    const pathElements = pathWithoutStartingSlash.split("/");
    const parameterToIndex = new Map<string, number>(
      pathElements
        // Pull out an [index, parameterName] pair for every path element that starts with ":"
        .map( (pathComponent, index) =>
          // Parameters must start after the first slash (/), begin with a ":",
          // and contain characters after the ":"
          (index > 0 && pathComponent.length > 1 && pathComponent.startsWith(":")) ?
            [pathComponent.replace(/[:?]/g, ""), index] as [string, number] :
            // return undefined if this isn't a path paramter so the filter (below) can remove
            // non-parameter elements from the list of parameters fed into the map constructor
            undefined
        )
        // Remove all undefineds created at positions where there was not a path parameter
        // so that the map constructor only receives parameters.
        .filter ( pathParameter => typeof(pathParameter) !== "undefined" ) as [string, number][]
    );
    const hasPathParameters = parameterToIndex.size > 0;

    if (RestContracts.isQueryParameterAPI(api)) {
      const methodFunction = api.method === RestContracts.Method.get ? Axios.get : Axios.delete;
      const hasQueryParameters = RestContracts.hasQueryParameters(api);

      return ( (...args: any[]) => {
        const parameters = (
          (hasPathParameters || hasQueryParameters) ?
          args.shift() : undefined
        ) as RestContracts.PATH_AND_QUERY_PARAMS<API>;
        const options = {...defaultOptions, ...(args.shift() || {} as RequestOptions)};
        const {pathWithParameters, remainingParameters} = assemblePath(pathElements, parameterToIndex, parameters);

        return wrapAxiosPromise<RestContracts.RESULT<typeof api>>(methodFunction(baseUrl + pathWithParameters, {...defaultOptions, ...options, params: remainingParameters }))
        }
      ) as RestContracts.ClientFunction<API, RequestOptions> ;
    } else if (RestContracts.isBodyParameterAPI(api)) {
      const hasBody = RestContracts.hasBody(api);
      const methodFunction = {
        post: Axios.post,
        put: Axios.put,
        patch: Axios.patch,
      }[api.method];

      return ( (...args: any[]) => {
        const parameters = (hasPathParameters ? args.shift() : undefined) as RestContracts.PATH_PARAMS<API>;
        const body = (hasBody ? args.shift() : undefined) as RestContracts.Body<API>;
        const options = {...defaultOptions, ...(args.shift() || {} as RequestOptions)};
        const {pathWithParameters} = assemblePath(pathElements, parameterToIndex, parameters);

        return wrapAxiosPromise(methodFunction(baseUrl + pathWithParameters, body, {...defaultOptions, ...options }));
      } ) as RestContracts.ClientFunction<API, RequestOptions> ;
    }
    throw new Error("Invalid method");
  }

