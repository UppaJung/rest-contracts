import Axios, { AxiosPromise, AxiosRequestConfig } from "axios";
import * as RestContracts from "rest-contracts";

export type RequestOptions = AxiosRequestConfig;

async function wrapAxiosPromise<T>(axiosPromise: AxiosPromise<T>) {
  try {
    const { data } = await axiosPromise;
    return data;
  } catch (error) {
    if (
      error != null && error.response && error.response.data &&
      error.response.data.error &&
      typeof (error.response.data.error) === "string"
    ) {
      throw JSON.parse(error.response.data.error);
    }
    throw error;
  }
}

function assemblePath(
  pathComponentArrayReadOnly: string[],
  parameterToIndexMap: Map<string, number>,
  pathParameters: RestContracts.PathParametersType = {}
): {
  pathWithParameters: string,
  remainingParameters: {[attribute: string]: any}
}  {
  const remainingParameters = {...pathParameters};
  const parameterIndexesSet = new Set(parameterToIndexMap.values());

  const pathWithParameters = "/" + pathComponentArrayReadOnly
    .map((pathComponent, index) => {
      if (!parameterIndexesSet.has(index)) {
        return pathComponent;
      }

      const pathParameterKey = pathComponent.replace(/[:?]/g, "");

      const value = pathParameters[pathParameterKey];
      delete remainingParameters[pathParameterKey];

      if (value) {
        return encodeURIComponent(value);
      }

      return null;
    })
    .filter(Boolean)
    .join("/");

  return {pathWithParameters, remainingParameters};
}


type RequestHandler<API extends RestContracts.AtPath & RestContracts.UsesMethod> =
  API extends RestContracts.UsesMethodSupportingBodyParameter ? (
    API extends RestContracts.PathParameters ? (
      (pathParams: RestContracts.PATH_PARAMS<API>, bodyParams: RestContracts.BODY_PARAMS<API>, options?: RequestOptions) => Promise<RestContracts.RESULT<API>>
    ) : (
      (bodyParams: RestContracts.BODY_PARAMS<API>, options?: RequestOptions) => Promise<RestContracts.RESULT<API>>
    )
  )
  :
  API extends RestContracts.UsesMethodSupportingQueryParameter ? (
    API extends RestContracts.PathParameters & RestContracts.QueryParameters ? (
      (pathAndQueryParameters: RestContracts.PATH_PARAMS<API> & RestContracts.QUERY_PARAMS<API>, options?: RequestOptions) => Promise<RestContracts.RESULT<API>>
    ) :
    API extends RestContracts.PathParameters ? (
        (pathAndQueryParameters: RestContracts.PATH_PARAMS<API>, options?: RequestOptions) => Promise<RestContracts.RESULT<API>>
    ) :
    API extends RestContracts.QueryParameters ? (
        (pathAndQueryParameters: RestContracts.QUERY_PARAMS<API>, options?: RequestOptions) => Promise<RestContracts.RESULT<API>>
    ) : (
      (options?: RequestOptions) => Promise<RestContracts.RESULT<API>>
    )
  )
  : never;

// type RequestFactory = <
// API extends RestContracts.AtPath & RestContracts.UsesMethod
// >(
//   api: API
// ) => RequestHandler<API>;

/**
 * Create a factory that will generated a promise-based client functions
 * to call the corresponding API function on the server.
 *
 * @param baseUrl The URL of the API server
 * @param defaultOptions Use to set default options for all API calls
 *   generated by this factory, which can be overriden during individual
 *   calls.  Options are timeoutInMs (default 0 indicating no timeout),
 *   headers (none), noCache (false), and withCredentials (true).
 */
export const getClientCreationFunction = (
  defaultBaseUrl: string = "",
  factoryDefaultOptions: RequestOptions = {}
) => <API extends RestContracts.AtPath & RestContracts.UsesMethod>(
    api: API,
    baseUrl: string = defaultBaseUrl,
    apiDefaultOptions: RequestOptions = {},
  ): RequestHandler<API> => {
    const defaultOptions: RequestOptions = {...factoryDefaultOptions, ...apiDefaultOptions};
    // Remove any trailing slashes from the base URL since the path will start with a slash
    baseUrl = baseUrl.replace(/\/+$/, "")
    const pathWithStartingSlash = (
      (baseUrl.length > 0 && baseUrl.charAt(baseUrl.length - 1) !== "/" && api.path.length > 0 && api.path.charAt(0) !== "/") ?
        "/" :
        ""
      ) + api.path;
    const pathWithoutStartingSlash = pathWithStartingSlash.substr(1);
    const pathElements = pathWithoutStartingSlash.split("/");
    const parameterToIndex = new Map<string, number>(
      pathElements
        // Pull out an [index, parameterName] pair for every path element that starts with ":"
        .map( (pathComponent, index) =>
          // Parameters must start after the first slash (/), begin with a ":",
          // and contain characters after the ":"
          (index > 0 && pathComponent.length > 1 && pathComponent.startsWith(":")) ?
            [pathComponent.replace(/[:?]/g, ""), index] as [string, number] :
            // return undefined if this isn't a path paramter so the filter (below) can remove
            // non-parameter elements from the list of parameters fed into the map constructor
            undefined
        )
        // Remove all undefineds created at positions where there was not a path parameter
        // so that the map constructor only receives parameters.
        .filter ( pathParameter => typeof(pathParameter) !== "undefined" ) as [string, number][]
    );
    const hasPathParameters = parameterToIndex.size > 0;

    if (RestContracts.isQueryParameterAPI(api)) {
      const methodFunction = api.method === RestContracts.Method.get ? Axios.get : Axios.delete;

      if (RestContracts.hasPathParameters(api)) {
        // Return a function with path parameters and query parameters specified together as one parameter
        return ( (
          parameters: RestContracts.PATH_AND_QUERY_PARAMS<typeof api>,
          options: RequestOptions = {}
        ) => {
          const {pathWithParameters, remainingParameters} = assemblePath(pathElements, parameterToIndex, parameters);

          return wrapAxiosPromise<RestContracts.RESULT<typeof api>>(methodFunction(baseUrl + pathWithParameters, {...defaultOptions, ...options, params: remainingParameters }));
        } ) as RequestHandler<API>;
      } else if (RestContracts.hasQueryParameters) {
        // Return a function with just query parameters
        return ( (
          queryParameters: RestContracts.PATH_AND_QUERY_PARAMS<API>,
          options: RequestOptions = {}
        ) => {
          return wrapAxiosPromise(methodFunction(baseUrl + pathWithStartingSlash, {...defaultOptions, ...options, params: queryParameters }));
        } ) as RequestHandler<API>;
      } else {
        // Return a function with no parameters
        return ( (
          options: RequestOptions = {}
        ) => {
          return wrapAxiosPromise(methodFunction(baseUrl + pathWithStartingSlash, {...defaultOptions, ...options }));
        } ) as RequestHandler<API>;
      }
    } else if (RestContracts.isBodyParameterAPI(api)) {
      const methodFunction = {
        post: Axios.post,
        put: Axios.put,
        patch: Axios.patch,
      }[api.method];
      if (hasPathParameters) {
        // Return a function with path parameters followed by body parameters
        return ( (
          pathParameters: RestContracts.PATH_PARAMS<API>,
          bodyParameters: RestContracts.BODY_PARAMS<API>,
          options: RequestOptions = {},
        ) => {
          const {pathWithParameters} = assemblePath(pathElements, parameterToIndex, pathParameters);

          return wrapAxiosPromise(methodFunction(baseUrl + pathWithParameters, bodyParameters, {...defaultOptions, ...options }));
        } ) as RequestHandler<API>;
      } else {
        // Return a function with body parameters but no path parameters
        return ( (
          bodyParameters: RestContracts.BODY_PARAMS<API>,
          options: RequestOptions = {},
        ) => {
          return wrapAxiosPromise(methodFunction(baseUrl + pathWithStartingSlash, bodyParameters, {...defaultOptions, ...options }));
        } ) as RequestHandler<API>;
      }
    }
    throw new Error("Invalid method");
  }

